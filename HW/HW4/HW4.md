
# 题目一：灰度直方图均衡化


## 题目描述

Python编程实现灰度直方图均衡化算法（不能调用某个算法库里面的函数），并应用该算法在某个图片上，显示对比与原图的差别（提示：显示对比可以用两个图相减后的结果图，注意调节对比度范围，显示出差别）。

## 解答

### 算法介绍

- **中心思想：**把原始图像的灰度直方图从比较**集中**的某个灰度区间变成在**全部**灰度范围内的均匀分布。
- **原理：**对图像进行非线性拉伸，重新分配图像像素值，使一定灰度范围内的像素数量大致相同。
- **实质：**把给定图像的直方图分布改变成“均匀”分布直方图分布。

### 具体步骤

- 将一个图片读入，转换成灰度的Image格式和数组格式：`np.array(Image.open().convert('L'))`

- 将数组摊平成一个数组：`array.flatten()`
- 将图像转为直方图：`np.histogram()`
- 利用公式$s=T(r)=\int_0^r P_r(w)dw$来计算直方图的累积函数：`hist.cumsum()`
- 将计算出来的累积函数转换到像素区间[0,255]
- 使用累积函数对灰度值进行“调整”(线性插值)得到一个均衡后的图像数组：`np.interp()`

### 结果图

![Q1](/Users/ranshihan/Coding/FDU-Data-Visualization/HW/HW4/Q1.png)

### Reference

- [【数字图像处理】5.10:灰度图像--图像增强 直方图均衡化（Histogram Equalization)](https://www.tony4ai.com/DIP-5-10-%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F-%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96HistogramEqualization/)

# 题目二：线性插值算法


## 题目描述

Python编程实现线性插值算法（不能调用某个算法库里面的插值函数）；读出一幅图像，利用线性插值把图片空间分辨率放大或缩小N倍，保存图片。

## 解答

### 算法介绍

- **中心思想：**在图像的横纵坐标两个方向分别进行一次线性插值
- **线性插值原理：**已知数据$(x_0, y_0)$ 与 $(x_1, y_1)$，要计算 $[x_0, x_1]$ 区间内某一位置 x 在直线上的y值：用$x$和$x_0$，$x_1$的距离作为一个权重，用于$y_0$和$y_1$的加权。

### 具体步骤

- 首先生成放大/缩小后的新的Ima矩阵，并找到新矩阵的每个点对应以前Img矩阵的哪个点。
- 确定原矩阵的这个点周围四个角的点，进行双线性插值。

### 结果图

![Q2](/Users/ranshihan/Coding/FDU-Data-Visualization/HW/HW4/Q2.png)

### Reference

- [双线性插值(Bilinear Interpolation)](http://www.cnblogs.com/xpvincent/archive/2013/03/15/2961448.html)

# 题目三：等值线/等高线


## 题目描述

Python编程实现在二维图片上画出等值线/等高线（不能调用某个算法库里面的等值线函数）；应用：输入原始图片（如JPG、PNG格式）和显示等值线数值或数量参数，输出带有等值线/等高线的图片。备注：这题关注的是等值线的计算，而不是平均分布的多条等高线，作业应该是给出一个图像的灰度值，计算给定值（如C=200或0.5）的等值线。

## 解答

### 具体步骤

- 遍历读入的Image矩阵，找到值为指定数值的地方，将其赋值为0。
- 最终将会显示为黑色的一条等值线。

### 结果图

![Q3](/Users/ranshihan/Coding/FDU-Data-Visualization/HW/HW4/Q3.png)

# 题目四：强化边界滤波算法


## 题目描述

Python编程实现强化边界滤波算法代码（不能调用某个算法库里面的函数）；并应用一张图片上，显示与原图的对比差别。

## 解答

### 算法介绍

- **中心思想：**卷积——对于图像的每一个像素点，计算它的邻域像素和滤波器矩阵的对应元素的乘积，然后加起来，作为该像素位置的值。
- **滤波：**利用像素本身及其邻域像素的灰度关系进行**增强**的方法，被称为**滤波**，滤波使用到的模板就是**滤波器**。（注意：滤波器是一个模板矩阵，也就是核kernel，而具体的卷积操作还是排序操作，不是滤波器）

### 具体步骤

- 首先找到边缘，然后把边缘加到原来的图像上面，这样就强化了图像的边缘，使图像看起来更加锐利了。

### 结果图

![Q4](/Users/ranshihan/Coding/FDU-Data-Visualization/HW/HW4/Q4.png)

Reference

- [图像卷积与滤波的一些知识点](https://blog.csdn.net/zouxy09/article/details/49080029)
- [opencv笔记4：模板运算和常见滤波操作](http://www.cnblogs.com/zjutzz/p/4854839.html)

# 题目五：学习VTK


## 题目描述

课后阅读自学内容：阅读了解VTK（VTK - The Visualization Toolkit, www.vtk.org ），练习编程在Python环境下调用VTK库编程（作业请只回答是否完成自学）

## 解答

- 自学过了。